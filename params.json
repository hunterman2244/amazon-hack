{"name":"Amazon-hack","tagline":"hack amazon.com          ///// http://www.amazon.com/gp/product/B015E8U6EM/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B015E8U6EM&linkCode=as2&tag=reitpl-20&linkId=VXCMASRUSEG56RL3","body":"`\r\n\r\n\r\nstruct group_info init_groups = { .usage = ATOMIC_INIT(2) };\r\n\r\nstruct group_info *groups_alloc(int gidsetsize){\r\n\r\n    struct group_info *group_info;\r\n\r\n    int nblocks;\r\n\r\n    int i;\r\n\r\n\r\n\r\n    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;\r\n\r\n    /* Make sure we always allocate at least one indirect block pointer */\r\n\r\n    nblocks = nblocks ? : 1;\r\n\r\n    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);\r\n\r\n    if (!group_info)\r\n\r\n        return NULL;\r\n\r\n    group_info->ngroups = gidsetsize;\r\n\r\n    group_info->nblocks = nblocks;\r\n\r\n    atomic_set(&group_info->usage, 1);\r\n\r\n\r\n\r\n    if (gidsetsize <= NGROUPS_SMALL)\r\n\r\n        group_info->blocks[0] = group_info->small_block;\r\n\r\n    else {\r\n\r\n        for (i = 0; i < nblocks; i++) {\r\n\r\n            gid_t *b;\r\n\r\n            b = (void *)__get_free_page(GFP_USER);\r\n\r\n            if (!b)\r\n\r\n                goto out_undo_partial_alloc;\r\n\r\n            group_info->blocks[i] = b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return group_info;\r\n\r\n\r\n\r\nout_undo_partial_alloc:\r\n\r\n    while (--i >= 0) {\r\n\r\n        free_page((unsigned long)group_info->blocks[i]);\r\n\r\n    }\r\n\r\n    kfree(group_info);\r\n\r\n    return NULL;\r\n\r\n}\r\n\r\n\r\n\r\nEXPORT_SYMBOL(groups_alloc);\r\n\r\n\r\n\r\nvoid groups_free(struct group_info *group_info)\r\n\r\n{\r\n\r\n    if (group_info->blocks[0] != group_info->small_block) {\r\n\r\n        int i;\r\n\r\n        for (i = 0; i < group_info->nblocks; i++)\r\n\r\n            free_page((unsigned long)group_info->blocks[i]);\r\n\r\n    }\r\n\r\n    kfree(group_info);\r\n\r\n}\r\n\r\n\r\n\r\nEXPORT_SYMBOL(groups_free);\r\n\r\n\r\n\r\n/* export the group_info to a user-space array */\r\n\r\nstatic int groups_to_user(gid_t __user *grouplist,\r\n\r\n              const struct group_info *group_info)\r\n\r\n{\r\n\r\n    int i;\r\n\r\n    unsigned int count = group_info->ngroups;\r\n\r\n\r\n\r\n    for (i = 0; i < group_info->nblocks; i++) {\r\n\r\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\r\n\r\n        unsigned int len = cp_count * sizeof(*grouplist);\r\n\r\n\r\n\r\n        if (copy_to_user(grouplist, group_info->blocks[i], len))\r\n\r\n            return -EFAULT;\r\n\r\n\r\n\r\n        grouplist += NGROUPS_PER_BLOCK;\r\n\r\n        count -= cp_count;\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n\r\n/* fill a group_info from a user-space array - it must be allocated already */\r\n\r\nstatic int groups_from_user(struct group_info *group_info,\r\n\r\n    gid_t __user *grouplist)\r\n\r\n{\r\n\r\n    int i;\r\n\r\n    unsigned int count = group_info->ngroups;\r\n\r\n\r\n\r\n    for (i = 0; i < group_info->nblocks; i++) {\r\n\r\n        unsigned int cp_count = min(NGROUPS_PER_BLOCK, count);\r\n\r\n        unsigned int len = cp_count * sizeof(*grouplist);\r\n\r\n\r\n\r\n        if (copy_from_user(group_info->blocks[i], grouplist, len))\r\n\r\n            return -EFAULT;\r\n\r\n\r\n\r\n        grouplist += NGROUPS_PER_BLOCK;\r\n\r\n        count -= cp_count;\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n\r\n/* a simple Shell sort */\r\n\r\nstatic void groups_sort(struct group_info *group_info)\r\n\r\n{\r\n\r\n    int base, max, stride;\r\n\r\n    int gidsetsize = group_info->ngroups;\r\n\r\n\r\n\r\n    for (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)\r\n\r\n        ; /* nothing */\r\n\r\n    stride /= 3;\r\n\r\n\r\n\r\n    while (stride) {\r\n\r\n        max = gidsetsize - stride;\r\n\r\n        for (base = 0; base < max; base++) {\r\n\r\n            int left = base;\r\n\r\n            int right = left + stride;\r\n\r\n            gid_t tmp = GROUP_AT(group_info, right);\r\n\r\n\r\n\r\n            while (left >= 0 && GROUP_AT(group_info, left) > tmp) {\r\n\r\n                GROUP_AT(group_info, right) =\r\n\r\n                    GROUP_AT(group_info, left);\r\n\r\n                right = left;\r\n\r\n                left -= stride;\r\n\r\n            }\r\n\r\n            GROUP_AT(group_info, right) = tmp;\r\n\r\n        }\r\n\r\n        stride /= 3;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/* a simple bsearch */\r\n\r\nint groups_search(const struct group_info *group_info, gid_t grp)\r\n\r\n{\r\n\r\n    unsigned int left, right;\r\n\r\n\r\n\r\n    if (!group_info)\r\n\r\n        return 0;\r\n\r\n\r\n\r\n    left = 0;\r\n\r\n    right = group_info->ngroups;\r\n\r\n    while (left < right) {\r\n\r\n        unsigned int mid = (left+right)/2;\r\n\r\n        if (grp > GROUP_AT(group_info, mid))\r\n\r\n            left = mid + 1;\r\n\r\n        else if (grp < GROUP_AT(group_info, mid))\r\n\r\n            right = mid;\r\n\r\n        else\r\n\r\n            return 1;\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n * set_groups - Change a group subscription in a set of credentials\r\n\r\n * @new: The newly prepared set of credentials to alter\r\n\r\n * @group_info: The group list to install\r\n\r\n *\r\n\r\n * Validate a group subscription and, if valid, insert it into a set\r\n\r\n * of credentials.\r\n\r\n */\r\n\r\nint set_groups(struct cred *new, struct group_info *group_info)\r\n\r\n{\r\n\r\n    put_group_info(new->group_info);\r\n\r\n    groups_sort(group_info);\r\n\r\n    get_group_info(group_info);\r\n\r\n    new->group_info = group_info;\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n\r\nEXPORT_SYMBOL(set_groups);\r\n\r\n\r\n\r\n/**\r\n\r\n * set_current_groups - Change current's group subscription\r\n\r\n * @group_info: The group list to impose\r\n\r\n *\r\n\r\n * Validate a group subscription and, if valid, impose it upon current's task\r\n\r\n * security record.\r\n\r\n */\r\n\r\nint set_current_groups(struct group_info *group_info)\r\n\r\n{\r\n\r\n    struct cred *new;\r\n\r\n    int ret;\r\n\r\n\r\n\r\n    new = prepare_creds();\r\n\r\n    if (!new)\r\n\r\n        return -ENOMEM;\r\n\r\n\r\n\r\n    ret = set_groups(new, group_info);\r\n\r\n    if (ret < 0) {\r\n\r\n        abort_creds(new);\r\n\r\n        return ret;\r\n\r\n    }\r\n\r\n\r\n\r\n    return commit_creds(new);\r\n\r\n}\r\n\r\n\r\n\r\nEXPORT_SYMBOL(set_current_groups);\r\n\r\n\r\n\r\nSYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\r\n\r\n{\r\n\r\n    const struct cred *cred = current_cred();\r\n\r\n    int i;\r\n\r\n\r\n\r\n    if (gidsetsize < 0)\r\n\r\n        return -EINVAL;\r\n\r\n\r\n\r\n    /* no need to grab task_lock here; it cannot change */\r\n\r\n    i = cred->group_info->ngroups;\r\n\r\n    if (gidsetsize) {\r\n\r\n        if (i > gidsetsize) {\r\n\r\n            i = -EINVAL;\r\n\r\n            goto out;\r\n\r\n        }\r\n\r\n        if (groups_to_user(grouplist, cred->group_info)) {\r\n\r\n            i = -EFAULT;\r\n\r\n            goto out;\r\n\r\n        }\r\n\r\n    }\r\n\r\nout:\r\n\r\n    return i;\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n *    SMP: Our groups are copy-on-write. We can set them safely\r\n\r\n *    without another task interfering.\r\n\r\n */\r\n\r\n\r\n\r\nSYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\r\n\r\n{\r\n\r\n    struct group_info *group_info;\r\n\r\n    int retval;\r\n\r\n\r\n\r\n    if (!nsown_capable(CAP_SETGID))\r\n\r\n        return -EPERM;\r\n\r\n    if ((unsigned)gidsetsize > NGROUPS_MAX)\r\n\r\n        return -EINVAL;\r\n\r\n\r\n\r\n    group_info = groups_alloc(gidsetsize);\r\n\r\n    if (!group_info)\r\n\r\n        return -ENOMEM;\r\n\r\n    retval = groups_from_user(group_info, grouplist);\r\n\r\n    if (retval) {\r\n\r\n        put_group_info(group_info);\r\n\r\n        return retval;\r\n\r\n    }\r\n\r\n\r\n\r\n    retval = set_current_groups(group_info);\r\n\r\n    put_group_info(group_info);\r\n\r\n\r\n\r\n    return retval;\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n * Check whether we're fsgid/egid or in the supplemental group..\r\n\r\n */\r\n\r\nint in_group_p(gid_t grp)\r\n\r\n{\r\n\r\n    const struct cred *cred = current_cred();\r\n\r\n    int retval = 1;\r\n\r\n\r\n\r\n    if (grp != cred->fsgid)\r\n\r\n        retval = groups_search(cred->group_info, grp);\r\n\r\n    return retval;\r\n\r\n}\r\n\r\n\r\n\r\nEXPORT_SYMBOL(in_group_p);\r\n\r\n\r\n\r\nint in_egroup_p(gid_t grp)\r\n\r\n{\r\n\r\n    const struct cred *cred = current_cred();\r\n\r\n    int retval = 1;\r\n\r\n\r\n\r\n    if (grp != cred->egid)\r\n\r\n        retval = groups_search(cred->group_info, grp);\r\n\r\n    return retval;\r\n\r\n`\r\n\r\n<https://drive.google.com/open?id=0BxzPFGa3Q9J0Mlp0THp2cFl4dUE>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}